//#include "stdafx.h"
#include "SSLContext.h"
#include "ace/SSL/sslconf.h"
#include "openssl/rand.h"
#include "openssl/x509.h"
#include "TProactor/SSL/SSL_Asynch_Stream.h"



static DH* dh512 = 0;
static DH* dh1024 = 0;

DH* get_dh512()
{
    static unsigned char dh512_p[]={
        0xF7,0x5C,0x85,0x3F,0xD4,0x8C,0xBA,0xF2,0x6F,0xF6,0x38,0xDD,
            0xE3,0x27,0x16,0x00,0x2D,0xE6,0x96,0xC9,0xFB,0x53,0x78,0xA1,
            0x0F,0xD1,0x2E,0xAD,0x4B,0xF0,0xB0,0x7C,0xF6,0xD6,0xFC,0xF6,
            0xA8,0x46,0xDC,0xD8,0x49,0x9E,0x73,0xD1,0xE4,0x9A,0x4C,0x4E,
            0x70,0x09,0xE8,0xDF,0x71,0x3A,0x8A,0x21,0x3E,0xB5,0xAD,0x36,
            0x88,0x83,0x2A,0x2B,
    };
    static unsigned char dh512_g[]={
        0x02,
    };
    DH *dh;

    if ((dh=DH_new()) == NULL) return(NULL);
    dh->p=BN_bin2bn(dh512_p,sizeof(dh512_p),NULL);
    dh->g=BN_bin2bn(dh512_g,sizeof(dh512_g),NULL);
    if ((dh->p == NULL) || (dh->g == NULL))
    { DH_free(dh); return(NULL); }
    return(dh);
}

DH* get_dh1024()
{
    static unsigned char dh1024_p[]={
        0xD7,0xFE,0xEC,0x06,0x28,0x03,0x34,0x96,0xB8,0x08,0x86,0x62,
            0xF1,0xA2,0xBA,0x84,0x7C,0xAF,0xA3,0x1F,0x6A,0x3D,0x03,0x20,
            0x81,0x8D,0x0E,0x43,0x3A,0x54,0x74,0x9F,0x83,0xD2,0xB7,0xE9,
            0x57,0xC1,0x67,0xE9,0x11,0x38,0x2B,0x8E,0x9B,0x1C,0x5D,0x14,
            0x18,0x7D,0x4F,0xEB,0xB1,0x4D,0xFA,0x6F,0x06,0xDD,0xDD,0x6D,
            0x9A,0xD0,0x9E,0x4F,0xE4,0x04,0x3E,0x86,0x6F,0x15,0x60,0x35,
            0x9B,0xA1,0xBA,0x53,0xBA,0x84,0xB5,0x06,0xB1,0xAD,0x94,0x25,
            0xD1,0xED,0xD2,0xF4,0xD7,0x02,0x2F,0x35,0x25,0xE7,0x2D,0x60,
            0xEE,0x7A,0x61,0xAD,0x98,0xA8,0x3D,0xAD,0xB1,0x8A,0x5E,0xCE,
            0xF0,0x09,0xD4,0x67,0x28,0x3D,0x52,0x64,0x78,0xBB,0xC3,0x9D,
            0x40,0xF4,0x72,0xDC,0xC9,0x31,0x0D,0xA3,
    };
    static unsigned char dh1024_g[]={
        0x02,
    };
    DH *dh;

    if ((dh=DH_new()) == NULL) return(NULL);
    dh->p=BN_bin2bn(dh1024_p,sizeof(dh1024_p),NULL);
    dh->g=BN_bin2bn(dh1024_g,sizeof(dh1024_g),NULL);
    if ((dh->p == NULL) || (dh->g == NULL))
    { DH_free(dh); return(NULL); }
    return(dh);
}

DH* tmp_dh_callback(SSL *s, int is_export, int keylength)
{
    ACE_UNUSED_ARG(s);
    ACE_UNUSED_ARG(is_export);

    switch (keylength) {
    case 512:
        if (dh512 == 0)
        {
            dh512 = get_dh512();
        }
        return dh512;
        break;
    case 1024:
        if (dh1024 == 0)
        {
            dh1024 = get_dh1024();
        }
        return dh1024;
        break;
    default:
        /* Generating a key on the fly is very costly, so use what is there */
        ACE_ERROR((LM_ERROR,
            ACE_TEXT("RPS_Implementation::tmp_dh_callback, unsupported key length, %d\n"),
            keylength));
    }
    return(0);
}

bool init_ssl()
{
    SSL_CTX_set_quiet_shutdown(ACE_SSL_Context::instance()->context(), 1);
    SSL_CTX_set_options(ACE_SSL_Context::instance()->context(), SSL_OP_SINGLE_DH_USE);
    SSL_CTX_set_tmp_dh_callback(ACE_SSL_Context::instance()->context(), tmp_dh_callback);

    if (SSL_CTX_set_cipher_list(ACE_SSL_Context::instance()->context(), "ADH"))
    {
        return true;
    }
    else
    {
        ACE_DEBUG((LM_ERROR,
            ACE_TEXT("SSL_CTX_set_cipher_list failed\n")));
        return false;
    }
    
}
